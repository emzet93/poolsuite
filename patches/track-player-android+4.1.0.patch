diff --git a/node_modules/track-player-android/ios/RNTrackPlayer.xcodeproj/project.pbxproj b/node_modules/track-player-android/ios/RNTrackPlayer.xcodeproj/project.pbxproj
deleted file mode 100644
index b61f0d5..0000000
--- a/node_modules/track-player-android/ios/RNTrackPlayer.xcodeproj/project.pbxproj
+++ /dev/null
@@ -1,370 +0,0 @@
-// !$*UTF8*$!
-{
-	archiveVersion = 1;
-	classes = {
-	};
-	objectVersion = 48;
-	objects = {
-
-/* Begin PBXBuildFile section */
-		9A0CF10E2046E5AC0093A5DF /* PitchAlgorithms.swift in Sources */ = {isa = PBXBuildFile; fileRef = 9A0CF10D2046E5AC0093A5DF /* PitchAlgorithms.swift */; };
-		9B0E282E1F07D76F00B71D2A /* RNTrackPlayerBridge.m in Sources */ = {isa = PBXBuildFile; fileRef = 9B0E282D1F07D76F00B71D2A /* RNTrackPlayerBridge.m */; };
-		9B0E282F1F07D76F00B71D2A /* RNTrackPlayerBridge.h in CopyFiles */ = {isa = PBXBuildFile; fileRef = 9B0E282C1F07D76F00B71D2A /* RNTrackPlayerBridge.h */; };
-		9B18C2FA226356560019375A /* SessionCategories.swift in Sources */ = {isa = PBXBuildFile; fileRef = 9B18C2F9226356560019375A /* SessionCategories.swift */; };
-		9B58DF3B1F40C0F000C2105E /* RNTrackPlayer.swift in Sources */ = {isa = PBXBuildFile; fileRef = 9B58DF3A1F40C0F000C2105E /* RNTrackPlayer.swift */; };
-		9B78A2461F3F12BC002B5E3C /* Track.swift in Sources */ = {isa = PBXBuildFile; fileRef = 9B78A2451F3F12BC002B5E3C /* Track.swift */; };
-		9B78A2481F3F12C9002B5E3C /* MediaURL.swift in Sources */ = {isa = PBXBuildFile; fileRef = 9B78A2471F3F12C9002B5E3C /* MediaURL.swift */; };
-		9BFC1FDD1F61A8E8008795BF /* Capabilities.swift in Sources */ = {isa = PBXBuildFile; fileRef = 9BFC1FDC1F61A8E8008795BF /* Capabilities.swift */; };
-		BF227390244F344D00A9893D /* Metadata.swift in Sources */ = {isa = PBXBuildFile; fileRef = 9B70466422BFFDEE00065A77 /* Metadata.swift */; };
-		F03B44972912BCA50035FE01 /* EventType.swift in Sources */ = {isa = PBXBuildFile; fileRef = F03B44952912BCA50035FE01 /* EventType.swift */; };
-		F03B44982912BCA50035FE01 /* EventEmitter.swift in Sources */ = {isa = PBXBuildFile; fileRef = F03B44962912BCA50035FE01 /* EventEmitter.swift */; };
-/* End PBXBuildFile section */
-
-/* Begin PBXCopyFilesBuildPhase section */
-		9B0E28271F07D76F00B71D2A /* CopyFiles */ = {
-			isa = PBXCopyFilesBuildPhase;
-			buildActionMask = 2147483647;
-			dstPath = "include/$(PRODUCT_NAME)";
-			dstSubfolderSpec = 16;
-			files = (
-				9B0E282F1F07D76F00B71D2A /* RNTrackPlayerBridge.h in CopyFiles */,
-			);
-			runOnlyForDeploymentPostprocessing = 0;
-		};
-/* End PBXCopyFilesBuildPhase section */
-
-/* Begin PBXFileReference section */
-		9A0CF10D2046E5AC0093A5DF /* PitchAlgorithms.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PitchAlgorithms.swift; sourceTree = "<group>"; };
-		9B0E28291F07D76F00B71D2A /* libRNTrackPlayer.a */ = {isa = PBXFileReference; explicitFileType = archive.ar; includeInIndex = 0; path = libRNTrackPlayer.a; sourceTree = BUILT_PRODUCTS_DIR; };
-		9B0E282C1F07D76F00B71D2A /* RNTrackPlayerBridge.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = RNTrackPlayerBridge.h; sourceTree = "<group>"; };
-		9B0E282D1F07D76F00B71D2A /* RNTrackPlayerBridge.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = RNTrackPlayerBridge.m; sourceTree = "<group>"; };
-		9B18C2F9226356560019375A /* SessionCategories.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = SessionCategories.swift; sourceTree = "<group>"; };
-		9B58DF3A1F40C0F000C2105E /* RNTrackPlayer.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = RNTrackPlayer.swift; sourceTree = "<group>"; };
-		9B70466422BFFDEE00065A77 /* Metadata.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = Metadata.swift; sourceTree = "<group>"; };
-		9B78A2451F3F12BC002B5E3C /* Track.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = Track.swift; sourceTree = "<group>"; };
-		9B78A2471F3F12C9002B5E3C /* MediaURL.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MediaURL.swift; sourceTree = "<group>"; };
-		9BFBA4D01F3DFA3F00453D3A /* RNTrackPlayer-Bridging-Header.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = "RNTrackPlayer-Bridging-Header.h"; sourceTree = "<group>"; };
-		9BFC1FDC1F61A8E8008795BF /* Capabilities.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = Capabilities.swift; sourceTree = "<group>"; };
-		F03B44952912BCA50035FE01 /* EventType.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = EventType.swift; sourceTree = "<group>"; };
-		F03B44962912BCA50035FE01 /* EventEmitter.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = EventEmitter.swift; sourceTree = "<group>"; };
-/* End PBXFileReference section */
-
-/* Begin PBXFrameworksBuildPhase section */
-		9B0E28261F07D76F00B71D2A /* Frameworks */ = {
-			isa = PBXFrameworksBuildPhase;
-			buildActionMask = 2147483647;
-			files = (
-			);
-			runOnlyForDeploymentPostprocessing = 0;
-		};
-/* End PBXFrameworksBuildPhase section */
-
-/* Begin PBXGroup section */
-		9B0E28201F07D76E00B71D2A = {
-			isa = PBXGroup;
-			children = (
-				9B0E282B1F07D76F00B71D2A /* RNTrackPlayer */,
-				9B0E282A1F07D76F00B71D2A /* Products */,
-			);
-			sourceTree = "<group>";
-		};
-		9B0E282A1F07D76F00B71D2A /* Products */ = {
-			isa = PBXGroup;
-			children = (
-				9B0E28291F07D76F00B71D2A /* libRNTrackPlayer.a */,
-			);
-			name = Products;
-			sourceTree = "<group>";
-		};
-		9B0E282B1F07D76F00B71D2A /* RNTrackPlayer */ = {
-			isa = PBXGroup;
-			children = (
-				9B70466322BFFDDD00065A77 /* Utils */,
-				9BFBA4D31F3DFA4B00453D3A /* Support */,
-				9B0E287A1F0831A400B71D2A /* Models */,
-				9B0E282C1F07D76F00B71D2A /* RNTrackPlayerBridge.h */,
-				9B0E282D1F07D76F00B71D2A /* RNTrackPlayerBridge.m */,
-				9B58DF3A1F40C0F000C2105E /* RNTrackPlayer.swift */,
-			);
-			path = RNTrackPlayer;
-			sourceTree = "<group>";
-		};
-		9B0E287A1F0831A400B71D2A /* Models */ = {
-			isa = PBXGroup;
-			children = (
-				9B78A2451F3F12BC002B5E3C /* Track.swift */,
-				9B78A2471F3F12C9002B5E3C /* MediaURL.swift */,
-				9BFC1FDC1F61A8E8008795BF /* Capabilities.swift */,
-				9A0CF10D2046E5AC0093A5DF /* PitchAlgorithms.swift */,
-				9B18C2F9226356560019375A /* SessionCategories.swift */,
-			);
-			path = Models;
-			sourceTree = "<group>";
-		};
-		9B70466322BFFDDD00065A77 /* Utils */ = {
-			isa = PBXGroup;
-			children = (
-				F03B44962912BCA50035FE01 /* EventEmitter.swift */,
-				F03B44952912BCA50035FE01 /* EventType.swift */,
-				9B70466422BFFDEE00065A77 /* Metadata.swift */,
-			);
-			path = Utils;
-			sourceTree = "<group>";
-		};
-		9BFBA4D31F3DFA4B00453D3A /* Support */ = {
-			isa = PBXGroup;
-			children = (
-				9BFBA4D01F3DFA3F00453D3A /* RNTrackPlayer-Bridging-Header.h */,
-			);
-			path = Support;
-			sourceTree = "<group>";
-		};
-/* End PBXGroup section */
-
-/* Begin PBXNativeTarget section */
-		9B0E28281F07D76F00B71D2A /* RNTrackPlayer */ = {
-			isa = PBXNativeTarget;
-			buildConfigurationList = 9B0E28321F07D76F00B71D2A /* Build configuration list for PBXNativeTarget "RNTrackPlayer" */;
-			buildPhases = (
-				9B0E28251F07D76F00B71D2A /* Sources */,
-				9B0E28261F07D76F00B71D2A /* Frameworks */,
-				9B0E28271F07D76F00B71D2A /* CopyFiles */,
-			);
-			buildRules = (
-			);
-			dependencies = (
-			);
-			name = RNTrackPlayer;
-			productName = RNTrackPlayer;
-			productReference = 9B0E28291F07D76F00B71D2A /* libRNTrackPlayer.a */;
-			productType = "com.apple.product-type.library.static";
-		};
-/* End PBXNativeTarget section */
-
-/* Begin PBXProject section */
-		9B0E28211F07D76E00B71D2A /* Project object */ = {
-			isa = PBXProject;
-			attributes = {
-				LastUpgradeCheck = 0900;
-				ORGANIZATIONNAME = "David Chavez";
-				TargetAttributes = {
-					9B0E28281F07D76F00B71D2A = {
-						CreatedOnToolsVersion = 9.0;
-						LastSwiftMigration = 0900;
-					};
-				};
-			};
-			buildConfigurationList = 9B0E28241F07D76E00B71D2A /* Build configuration list for PBXProject "RNTrackPlayer" */;
-			compatibilityVersion = "Xcode 8.0";
-			developmentRegion = en;
-			hasScannedForEncodings = 0;
-			knownRegions = (
-				en,
-			);
-			mainGroup = 9B0E28201F07D76E00B71D2A;
-			productRefGroup = 9B0E282A1F07D76F00B71D2A /* Products */;
-			projectDirPath = "";
-			projectRoot = "";
-			targets = (
-				9B0E28281F07D76F00B71D2A /* RNTrackPlayer */,
-			);
-		};
-/* End PBXProject section */
-
-/* Begin PBXSourcesBuildPhase section */
-		9B0E28251F07D76F00B71D2A /* Sources */ = {
-			isa = PBXSourcesBuildPhase;
-			buildActionMask = 2147483647;
-			files = (
-				9B0E282E1F07D76F00B71D2A /* RNTrackPlayerBridge.m in Sources */,
-				9B18C2FA226356560019375A /* SessionCategories.swift in Sources */,
-				BF227390244F344D00A9893D /* Metadata.swift in Sources */,
-				F03B44982912BCA50035FE01 /* EventEmitter.swift in Sources */,
-				9B78A2481F3F12C9002B5E3C /* MediaURL.swift in Sources */,
-				F03B44972912BCA50035FE01 /* EventType.swift in Sources */,
-				9BFC1FDD1F61A8E8008795BF /* Capabilities.swift in Sources */,
-				9B78A2461F3F12BC002B5E3C /* Track.swift in Sources */,
-				9A0CF10E2046E5AC0093A5DF /* PitchAlgorithms.swift in Sources */,
-				9B58DF3B1F40C0F000C2105E /* RNTrackPlayer.swift in Sources */,
-			);
-			runOnlyForDeploymentPostprocessing = 0;
-		};
-/* End PBXSourcesBuildPhase section */
-
-/* Begin XCBuildConfiguration section */
-		9B0E28301F07D76F00B71D2A /* Debug */ = {
-			isa = XCBuildConfiguration;
-			buildSettings = {
-				ALWAYS_SEARCH_USER_PATHS = NO;
-				CLANG_ANALYZER_NONNULL = YES;
-				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
-				CLANG_CXX_LANGUAGE_STANDARD = "gnu++14";
-				CLANG_CXX_LIBRARY = "libc++";
-				CLANG_ENABLE_MODULES = YES;
-				CLANG_ENABLE_OBJC_ARC = YES;
-				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
-				CLANG_WARN_BOOL_CONVERSION = YES;
-				CLANG_WARN_COMMA = YES;
-				CLANG_WARN_CONSTANT_CONVERSION = YES;
-				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
-				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
-				CLANG_WARN_EMPTY_BODY = YES;
-				CLANG_WARN_ENUM_CONVERSION = YES;
-				CLANG_WARN_INFINITE_RECURSION = YES;
-				CLANG_WARN_INT_CONVERSION = YES;
-				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
-				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
-				CLANG_WARN_STRICT_PROTOTYPES = YES;
-				CLANG_WARN_SUSPICIOUS_MOVE = YES;
-				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
-				CLANG_WARN_UNREACHABLE_CODE = YES;
-				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
-				CODE_SIGN_IDENTITY = "iPhone Developer";
-				COPY_PHASE_STRIP = NO;
-				DEBUG_INFORMATION_FORMAT = dwarf;
-				ENABLE_STRICT_OBJC_MSGSEND = YES;
-				ENABLE_TESTABILITY = YES;
-				GCC_C_LANGUAGE_STANDARD = gnu11;
-				GCC_DYNAMIC_NO_PIC = NO;
-				GCC_NO_COMMON_BLOCKS = YES;
-				GCC_OPTIMIZATION_LEVEL = 0;
-				GCC_PREPROCESSOR_DEFINITIONS = (
-					"DEBUG=1",
-					"$(inherited)",
-				);
-				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
-				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
-				GCC_WARN_UNDECLARED_SELECTOR = YES;
-				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
-				GCC_WARN_UNUSED_FUNCTION = YES;
-				GCC_WARN_UNUSED_VARIABLE = YES;
-				IPHONEOS_DEPLOYMENT_TARGET = 10.0;
-				MTL_ENABLE_DEBUG_INFO = YES;
-				ONLY_ACTIVE_ARCH = YES;
-				SDKROOT = iphoneos;
-				SWIFT_VERSION = 4.2;
-			};
-			name = Debug;
-		};
-		9B0E28311F07D76F00B71D2A /* Release */ = {
-			isa = XCBuildConfiguration;
-			buildSettings = {
-				ALWAYS_SEARCH_USER_PATHS = NO;
-				CLANG_ANALYZER_NONNULL = YES;
-				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
-				CLANG_CXX_LANGUAGE_STANDARD = "gnu++14";
-				CLANG_CXX_LIBRARY = "libc++";
-				CLANG_ENABLE_MODULES = YES;
-				CLANG_ENABLE_OBJC_ARC = YES;
-				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
-				CLANG_WARN_BOOL_CONVERSION = YES;
-				CLANG_WARN_COMMA = YES;
-				CLANG_WARN_CONSTANT_CONVERSION = YES;
-				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
-				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
-				CLANG_WARN_EMPTY_BODY = YES;
-				CLANG_WARN_ENUM_CONVERSION = YES;
-				CLANG_WARN_INFINITE_RECURSION = YES;
-				CLANG_WARN_INT_CONVERSION = YES;
-				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
-				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
-				CLANG_WARN_STRICT_PROTOTYPES = YES;
-				CLANG_WARN_SUSPICIOUS_MOVE = YES;
-				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
-				CLANG_WARN_UNREACHABLE_CODE = YES;
-				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
-				CODE_SIGN_IDENTITY = "iPhone Developer";
-				COPY_PHASE_STRIP = NO;
-				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
-				ENABLE_NS_ASSERTIONS = NO;
-				ENABLE_STRICT_OBJC_MSGSEND = YES;
-				GCC_C_LANGUAGE_STANDARD = gnu11;
-				GCC_NO_COMMON_BLOCKS = YES;
-				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
-				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
-				GCC_WARN_UNDECLARED_SELECTOR = YES;
-				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
-				GCC_WARN_UNUSED_FUNCTION = YES;
-				GCC_WARN_UNUSED_VARIABLE = YES;
-				IPHONEOS_DEPLOYMENT_TARGET = 10.0;
-				MTL_ENABLE_DEBUG_INFO = NO;
-				SDKROOT = iphoneos;
-				SWIFT_VERSION = 4.2;
-				VALIDATE_PRODUCT = YES;
-			};
-			name = Release;
-		};
-		9B0E28331F07D76F00B71D2A /* Debug */ = {
-			isa = XCBuildConfiguration;
-			buildSettings = {
-				CLANG_ENABLE_MODULES = YES;
-				DEFINES_MODULE = YES;
-				DEVELOPMENT_TEAM = B82TF96752;
-				HEADER_SEARCH_PATHS = (
-					"$(inherited)",
-					"$(SRCROOT)/../../../React/**",
-					"$(SRCROOT)/../../react-native/React/**",
-				);
-				LD_RUNPATH_SEARCH_PATHS = "$(inherited) @executable_path/Frameworks @loader_path/Frameworks";
-				OTHER_LDFLAGS = (
-					"$(inherited)",
-					"-ObjC",
-				);
-				PRODUCT_NAME = "$(TARGET_NAME)";
-				SKIP_INSTALL = YES;
-				SWIFT_OBJC_BRIDGING_HEADER = "RNTrackPlayer/Support/RNTrackPlayer-Bridging-Header.h";
-				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
-				SWIFT_VERSION = 4.2;
-				TARGETED_DEVICE_FAMILY = "1,2";
-			};
-			name = Debug;
-		};
-		9B0E28341F07D76F00B71D2A /* Release */ = {
-			isa = XCBuildConfiguration;
-			buildSettings = {
-				CLANG_ENABLE_MODULES = YES;
-				DEFINES_MODULE = YES;
-				DEVELOPMENT_TEAM = B82TF96752;
-				HEADER_SEARCH_PATHS = (
-					"$(inherited)",
-					"$(SRCROOT)/../../../React/**",
-					"$(SRCROOT)/../../react-native/React/**",
-				);
-				LD_RUNPATH_SEARCH_PATHS = "$(inherited) @executable_path/Frameworks @loader_path/Frameworks";
-				OTHER_LDFLAGS = (
-					"$(inherited)",
-					"-ObjC",
-				);
-				PRODUCT_NAME = "$(TARGET_NAME)";
-				SKIP_INSTALL = YES;
-				SWIFT_OBJC_BRIDGING_HEADER = "RNTrackPlayer/Support/RNTrackPlayer-Bridging-Header.h";
-				SWIFT_VERSION = 4.2;
-				TARGETED_DEVICE_FAMILY = "1,2";
-			};
-			name = Release;
-		};
-/* End XCBuildConfiguration section */
-
-/* Begin XCConfigurationList section */
-		9B0E28241F07D76E00B71D2A /* Build configuration list for PBXProject "RNTrackPlayer" */ = {
-			isa = XCConfigurationList;
-			buildConfigurations = (
-				9B0E28301F07D76F00B71D2A /* Debug */,
-				9B0E28311F07D76F00B71D2A /* Release */,
-			);
-			defaultConfigurationIsVisible = 0;
-			defaultConfigurationName = Release;
-		};
-		9B0E28321F07D76F00B71D2A /* Build configuration list for PBXNativeTarget "RNTrackPlayer" */ = {
-			isa = XCConfigurationList;
-			buildConfigurations = (
-				9B0E28331F07D76F00B71D2A /* Debug */,
-				9B0E28341F07D76F00B71D2A /* Release */,
-			);
-			defaultConfigurationIsVisible = 0;
-			defaultConfigurationName = Release;
-		};
-/* End XCConfigurationList section */
-	};
-	rootObject = 9B0E28211F07D76E00B71D2A /* Project object */;
-}
diff --git a/node_modules/track-player-android/ios/RNTrackPlayer.xcodeproj/project.xcworkspace/contents.xcworkspacedata b/node_modules/track-player-android/ios/RNTrackPlayer.xcodeproj/project.xcworkspace/contents.xcworkspacedata
deleted file mode 100644
index 102bec9..0000000
--- a/node_modules/track-player-android/ios/RNTrackPlayer.xcodeproj/project.xcworkspace/contents.xcworkspacedata
+++ /dev/null
@@ -1,7 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<Workspace
-   version = "1.0">
-   <FileRef
-      location = "self:RNTrackPlayer.xcodeproj">
-   </FileRef>
-</Workspace>
diff --git a/node_modules/track-player-android/ios/RNTrackPlayer/Models/Capabilities.swift b/node_modules/track-player-android/ios/RNTrackPlayer/Models/Capabilities.swift
deleted file mode 100644
index f56bf99..0000000
--- a/node_modules/track-player-android/ios/RNTrackPlayer/Models/Capabilities.swift
+++ /dev/null
@@ -1,53 +0,0 @@
-//
-//  Capabilities.swift
-//  RNTrackPlayer
-//
-//  Created by David Chavez on 07.09.17.
-//  Copyright © 2017 David Chavez. All rights reserved.
-//
-
-import Foundation
-import SwiftAudioEx
-
-enum Capability: String {
-    case play, pause, togglePlayPause, stop, next, previous, jumpForward, jumpBackward, seek, like, dislike, bookmark
-
-    func mapToPlayerCommand(forwardJumpInterval: NSNumber?,
-                            backwardJumpInterval: NSNumber?,
-                            likeOptions: [String: Any]?,
-                            dislikeOptions: [String: Any]?,
-                            bookmarkOptions: [String: Any]?) -> RemoteCommand {
-        switch self {
-        case .stop:
-            return .stop
-        case .play:
-            return .play
-        case .pause:
-            return .pause
-        case .togglePlayPause:
-            return .togglePlayPause
-        case .next:
-            return .next
-        case .previous:
-            return .previous
-        case .seek:
-            return .changePlaybackPosition
-        case .jumpForward:
-            return .skipForward(preferredIntervals: [(forwardJumpInterval ?? backwardJumpInterval) ?? 15])
-        case .jumpBackward:
-            return .skipBackward(preferredIntervals: [(backwardJumpInterval ?? forwardJumpInterval) ?? 15])
-        case .like:
-            return .like(isActive: likeOptions?["isActive"] as? Bool ?? false,
-                         localizedTitle: likeOptions?["title"] as? String ?? "Like",
-                         localizedShortTitle: likeOptions?["title"] as? String ?? "Like")
-        case .dislike:
-            return .dislike(isActive: dislikeOptions?["isActive"] as? Bool ?? false,
-                            localizedTitle: dislikeOptions?["title"] as? String ?? "Dislike",
-                            localizedShortTitle: dislikeOptions?["title"] as? String ?? "Dislike")
-        case .bookmark:
-            return .bookmark(isActive: bookmarkOptions?["isActive"] as? Bool ?? false,
-                             localizedTitle: bookmarkOptions?["title"] as? String ?? "Bookmark",
-                             localizedShortTitle: bookmarkOptions?["title"] as? String ?? "Bookmark")
-        }
-    }
-}
diff --git a/node_modules/track-player-android/ios/RNTrackPlayer/Models/MediaURL.swift b/node_modules/track-player-android/ios/RNTrackPlayer/Models/MediaURL.swift
deleted file mode 100644
index 47fc694..0000000
--- a/node_modules/track-player-android/ios/RNTrackPlayer/Models/MediaURL.swift
+++ /dev/null
@@ -1,37 +0,0 @@
-//
-//  MediaURL.swift
-//  RNTrackPlayer
-//
-//  Created by David Chavez on 12.08.17.
-//  Copyright © 2017 David Chavez. All rights reserved.
-//
-
-import Foundation
-
-struct MediaURL {
-    let value: URL
-    let isLocal: Bool
-    private let originalObject: Any
-    
-    init?(object: Any?) {
-        guard let object = object else { return nil }
-        originalObject = object
-        
-        // This is based on logic found in RCTConvert NSURLRequest, 
-        // and uses RCTConvert NSURL to create a valid URL from various formats
-        if let localObject = object as? [String: Any] {
-            var url = localObject["uri"] as? String ?? localObject["url"] as! String
-            
-            if let bundleName = localObject["bundle"] as? String {
-                url = String(format: "%@.bundle/%@", bundleName, url)
-            }
-            
-            isLocal = url.lowercased().hasPrefix("http") ? false : true
-            value = RCTConvert.nsurl(url)
-        } else {
-            let url = object as! String
-            isLocal = url.lowercased().hasPrefix("file://")
-            value = RCTConvert.nsurl(url)
-        }
-    }
-}
diff --git a/node_modules/track-player-android/ios/RNTrackPlayer/Models/MetadataAdapter.swift b/node_modules/track-player-android/ios/RNTrackPlayer/Models/MetadataAdapter.swift
deleted file mode 100644
index 0924da6..0000000
--- a/node_modules/track-player-android/ios/RNTrackPlayer/Models/MetadataAdapter.swift
+++ /dev/null
@@ -1,147 +0,0 @@
-//
-//  MetadataAdapter.swift
-//  react-native-track-player
-//
-//  Created by David Chavez on 01.08.23.
-//  Copyright © 2023 Double Symmetry. All rights reserved.
-//
-
-import Foundation
-import AVFoundation
-
-typealias RawMetadataGroup = [[String: Any]]
-
-class MetadataAdapter {
-    private static func getMetadataItem(metadata: [AVMetadataItem], forIdentifier: AVMetadataIdentifier) -> String? {
-        return AVMetadataItem.metadataItems(from: metadata, filteredByIdentifier: forIdentifier).first?.stringValue
-    }
-    
-    private static func convertToSerializableItems(items: [AVMetadataItem]) -> RawMetadataGroup {
-        var rawGroup: RawMetadataGroup = []
-        
-        for metadataItem in items {
-            var rawMetadataItem: [String: Any] = [:]
-            rawMetadataItem["time"] = metadataItem.time.seconds
-            rawMetadataItem["value"] = metadataItem.value
-            rawMetadataItem["key"] = metadataItem.key
-            if let commonKey = metadataItem.commonKey?.rawValue {
-                rawMetadataItem["commonKey"] = commonKey
-            }
-            if let keySpace = metadataItem.keySpace?.rawValue {
-                rawMetadataItem["keySpace"] = keySpace
-            }
-            
-            rawGroup.append(rawMetadataItem)
-        }
-        
-        return rawGroup
-    }
-    
-    // MARK: - Public
-    
-    static func convertToGroupedMetadata(metadataGroups: [AVTimedMetadataGroup]) -> RawMetadataGroup {
-        var ret: RawMetadataGroup  = []
-        
-        for metadataGroup in metadataGroups {
-            let entry = convertToCommonMetadata(metadata: metadataGroup.items)
-            ret.append(entry)
-        }
-        
-        return ret
-    }
-    
-    static func convertToCommonMetadata(metadata: [AVMetadataItem], skipRaw: Bool = false) -> [String: Any] {
-        var rawMetadataItem: [String: Any] = [:]
-        rawMetadataItem["title"] = getMetadataItem(metadata: metadata, forIdentifier: .commonIdentifierTitle)
-        rawMetadataItem["artist"] = getMetadataItem(metadata: metadata, forIdentifier: .commonIdentifierArtist)
-        rawMetadataItem["albumName"] = getMetadataItem(metadata: metadata, forIdentifier: .commonIdentifierAlbumName)
-        rawMetadataItem["subtitle"] = getMetadataItem(metadata: metadata, forIdentifier: .id3MetadataSetSubtitle)
-            ?? getMetadataItem(metadata: metadata, forIdentifier: .iTunesMetadataTrackSubTitle)
-        rawMetadataItem["description"] = getMetadataItem(metadata: metadata, forIdentifier: .commonIdentifierDescription)
-        rawMetadataItem["artworkUri"] = getMetadataItem(metadata: metadata, forIdentifier: .commonIdentifierArtwork)
-        rawMetadataItem["trackNumber"] = getMetadataItem(metadata: metadata, forIdentifier: .id3MetadataTrackNumber)
-            ?? getMetadataItem(metadata: metadata, forIdentifier: .iTunesMetadataTrackNumber)
-        rawMetadataItem["composer"] = getMetadataItem(metadata: metadata, forIdentifier: .id3MetadataComposer)
-            ?? getMetadataItem(metadata: metadata, forIdentifier: .iTunesMetadataComposer)
-            ?? getMetadataItem(metadata: metadata, forIdentifier: .quickTimeMetadataComposer)
-        rawMetadataItem["conductor"] = getMetadataItem(metadata: metadata, forIdentifier: .id3MetadataConductor)
-            ?? getMetadataItem(metadata: metadata, forIdentifier: .iTunesMetadataConductor)
-        rawMetadataItem["genre"] = getMetadataItem(metadata: metadata, forIdentifier: .quickTimeMetadataGenre)
-        rawMetadataItem["compilation"] = getMetadataItem(metadata: metadata, forIdentifier: .iTunesMetadataDiscCompilation)
-        rawMetadataItem["station"] = getMetadataItem(metadata: metadata, forIdentifier: .id3MetadataInternetRadioStationName)
-        rawMetadataItem["mediaType"] = getMetadataItem(metadata: metadata, forIdentifier: .id3MetadataMediaType)
-        rawMetadataItem["creationDate"] = getMetadataItem(metadata: metadata, forIdentifier: .commonIdentifierCreationDate)
-        rawMetadataItem["creationYear"] = getMetadataItem(metadata: metadata, forIdentifier: .id3MetadataYear)
-            ?? getMetadataItem(metadata: metadata, forIdentifier: .quickTimeMetadataYear)
-        
-        if !skipRaw {
-            rawMetadataItem["raw"] = convertToSerializableItems(items: metadata)
-        }
-        
-        return rawMetadataItem
-    }
-    
-    @available(*, deprecated, message: "Will be removed down the line")
-    static func legacyConversion(metadata: [AVMetadataItem]) -> [String : String?] {
-        var source: String {
-            switch metadata.first?.keySpace {
-            case AVMetadataKeySpace.id3:
-                return "id3"
-            case AVMetadataKeySpace.icy:
-                return "icy"
-            case AVMetadataKeySpace.quickTimeMetadata:
-                return "quicktime"
-            case AVMetadataKeySpace.common:
-                return "unknown"
-            default: return "unknown"
-            }
-        }
-
-        let album = getMetadataItem(metadata: metadata, forIdentifier: .commonIdentifierAlbumName) ?? ""
-        var artist = getMetadataItem(metadata: metadata, forIdentifier: .commonIdentifierArtist) ?? ""
-        var title = getMetadataItem(metadata: metadata, forIdentifier: .commonIdentifierTitle) ?? ""
-        var date = getMetadataItem(metadata: metadata, forIdentifier: .commonIdentifierCreationDate) ?? ""
-        var url = "";
-        var genre = "";
-        if (source == "icy") {
-            url = getMetadataItem(metadata: metadata, forIdentifier: .icyMetadataStreamURL) ?? ""
-        } else if (source == "id3") {
-            if (date.isEmpty) {
-                date = getMetadataItem(metadata: metadata, forIdentifier: .id3MetadataDate) ?? ""
-            }
-            genre = getMetadataItem(metadata: metadata, forIdentifier: .id3MetadataContentType) ?? ""
-            url = getMetadataItem(metadata: metadata, forIdentifier: .id3MetadataOfficialAudioSourceWebpage) ?? ""
-            if (url.isEmpty) {
-                url = getMetadataItem(metadata: metadata, forIdentifier: .id3MetadataOfficialAudioFileWebpage) ?? ""
-            }
-            if (url.isEmpty) {
-                url = getMetadataItem(metadata: metadata, forIdentifier: .id3MetadataOfficialArtistWebpage) ?? ""
-            }
-        } else if (source == "quicktime") {
-            genre = getMetadataItem(metadata: metadata, forIdentifier: .quickTimeMetadataGenre) ?? ""
-        }
-
-        // Detect ICY metadata and split title into artist & title:
-        // - source should be either "unknown" (pre iOS 14) or "icy" (iOS 14 and above)
-        // - we have a title, but no artist
-        if ((source == "unknown" || source == "icy") && !title.isEmpty && artist.isEmpty) {
-            if let index = title.range(of: " - ")?.lowerBound {
-                artist = String(title.prefix(upTo: index));
-                title = String(title.suffix(from: title.index(index, offsetBy: 3)));
-            }
-        }
-        var data : [String : String?] = [
-            "title": title.isEmpty ? nil : title,
-            "url": url.isEmpty ? nil : url,
-            "artist": artist.isEmpty ? nil : artist,
-            "album": album.isEmpty ? nil : album,
-            "date": date.isEmpty ? nil : date,
-            "genre": genre.isEmpty ? nil : genre
-        ]
-        if (data.values.contains { $0 != nil }) {
-            data["source"] = source
-        }
-        
-        return data
-    }
-}
diff --git a/node_modules/track-player-android/ios/RNTrackPlayer/Models/PitchAlgorithms.swift b/node_modules/track-player-android/ios/RNTrackPlayer/Models/PitchAlgorithms.swift
deleted file mode 100644
index 2923ce8..0000000
--- a/node_modules/track-player-android/ios/RNTrackPlayer/Models/PitchAlgorithms.swift
+++ /dev/null
@@ -1,13 +0,0 @@
-//
-//  PitchAlgorithms.swift
-//  RNTrackPlayer
-//
-//  Created by Anders Lemke on 28/02/2018.
-//  Copyright © 2018 David Chavez. All rights reserved.
-//
-
-import Foundation
-
-enum PitchAlgorithm: String {
-    case linear, music, voice
-}
diff --git a/node_modules/track-player-android/ios/RNTrackPlayer/Models/SessionCategories.swift b/node_modules/track-player-android/ios/RNTrackPlayer/Models/SessionCategories.swift
deleted file mode 100644
index 461fa1f..0000000
--- a/node_modules/track-player-android/ios/RNTrackPlayer/Models/SessionCategories.swift
+++ /dev/null
@@ -1,106 +0,0 @@
-//
-//  SessionCategory.swift
-//  RNTrackPlayer
-//
-//  Created by Thomas Hessler on 3/12/19.
-//  Copyright © 2019 David Chavez. All rights reserved.
-//
-
-import Foundation
-import MediaPlayer
-import AVFoundation
-
-enum SessionCategory: String {
-    case playAndRecord, multiRoute, playback, ambient, soloAmbient
-    
-    func mapConfigToAVAudioSessionCategory() -> AVAudioSession.Category {
-        switch self {
-        case .playAndRecord:
-            return .playAndRecord
-        case .multiRoute:
-            return .multiRoute
-        case .playback:
-            return .playback
-        case .ambient:
-            return .ambient
-        case .soloAmbient:
-            return .soloAmbient
-        }
-    }
-}
-
-enum SessionCategoryPolicy: String {
-    case `default`, longFormAudio, independent, longFormVideo
-    
-    func mapConfigToAVAudioSessionCategoryPolicy() -> AVAudioSession.RouteSharingPolicy {
-        switch self {
-        case .default:
-            return .default
-        case .longFormAudio:
-            return .longFormAudio
-        case .independent:
-            return .independent
-        case .longFormVideo:
-            if #available(iOS 13.0, *) {
-                return .longFormVideo
-            } else {
-                return .longFormAudio
-            }
-        }
-    }
-}
-
-enum SessionCategoryMode: String {
-    case `default`, gameChat, measurement, moviePlayback, spokenAudio, videoChat, videoRecording, voiceChat, voicePrompt
-    
-    func mapConfigToAVAudioSessionCategoryMode() -> AVAudioSession.Mode {
-        switch self {
-        case .default:
-            return .default
-        case .gameChat:
-            return .gameChat
-        case .measurement:
-            return .measurement
-        case .moviePlayback:
-            return .moviePlayback
-        case .spokenAudio:
-            return .spokenAudio
-        case .videoChat:
-            return .videoChat
-        case .videoRecording:
-            return .videoRecording
-        case .voiceChat:
-            return .voiceChat
-        case .voicePrompt:
-            if #available(iOS 12.0, *) {
-                return .voicePrompt
-            } else {
-                // Do Nothing
-                return .default
-            }
-        }
-    }
-}
-
-enum SessionCategoryOptions : String {
-    case mixWithOthers, duckOthers, interruptSpokenAudioAndMixWithOthers, allowBluetooth, allowBluetoothA2DP, allowAirPlay, defaultToSpeaker
-    
-    func mapConfigToAVAudioSessionCategoryOptions() -> AVAudioSession.CategoryOptions? {
-        switch self {
-        case .mixWithOthers:
-            return .mixWithOthers
-        case .duckOthers:
-            return .duckOthers
-        case .interruptSpokenAudioAndMixWithOthers:
-            return .interruptSpokenAudioAndMixWithOthers
-        case .allowBluetooth:
-            return .allowBluetooth
-        case .allowBluetoothA2DP:
-            return .allowBluetoothA2DP
-        case .allowAirPlay:
-            return .allowAirPlay
-        case .defaultToSpeaker:
-            return .defaultToSpeaker
-        }
-    }
-}
diff --git a/node_modules/track-player-android/ios/RNTrackPlayer/Models/State.swift b/node_modules/track-player-android/ios/RNTrackPlayer/Models/State.swift
deleted file mode 100644
index fb22ff8..0000000
--- a/node_modules/track-player-android/ios/RNTrackPlayer/Models/State.swift
+++ /dev/null
@@ -1,27 +0,0 @@
-//
-//  State.swift
-//  RNTrackPlayer
-//
-//  Created by David Chavez on 02.12.21.
-//
-
-import Foundation
-import SwiftAudioEx
-
-enum State: String {
-    case none, ready, playing, paused, stopped, buffering, loading, error, ended
-
-    static func fromPlayerState(state: AVPlayerWrapperState) -> State {
-        switch state {
-        case .paused: return .paused
-        case .buffering: return .buffering
-        case .idle: return .none
-        case .loading: return .loading
-        case .playing: return .playing
-        case .ready: return .ready
-        case .failed: return .error
-        case .stopped: return .stopped
-        case .ended: return .ended
-        }
-    }
-}
diff --git a/node_modules/track-player-android/ios/RNTrackPlayer/Models/Track.swift b/node_modules/track-player-android/ios/RNTrackPlayer/Models/Track.swift
deleted file mode 100644
index 0c4cc61..0000000
--- a/node_modules/track-player-android/ios/RNTrackPlayer/Models/Track.swift
+++ /dev/null
@@ -1,141 +0,0 @@
-//
-//  Track.swift
-//  RNTrackPlayer
-//
-//  Created by David Chavez on 12.08.17.
-//  Copyright © 2017 David Chavez. All rights reserved.
-//
-
-import Foundation
-import MediaPlayer
-import AVFoundation
-import SwiftAudioEx
-
-class Track: AudioItem, TimePitching, AssetOptionsProviding {
-    let url: MediaURL
-
-    @objc var title: String?
-    @objc var artist: String?
-
-    var date: String?
-    var desc: String?
-    var genre: String?
-    var duration: Double?
-    var artworkURL: MediaURL?
-    let headers: [String: Any]?
-    var userAgent: String?
-    let pitchAlgorithm: String?
-    var isLiveStream: Bool?
-
-    var album: String?
-    var artwork: MPMediaItemArtwork?
-
-    private var originalObject: [String: Any] = [:]
-
-    init?(dictionary: [String: Any]) {
-        guard let url = MediaURL(object: dictionary["url"]) else { return nil }
-        self.url = url
-        self.headers = dictionary["headers"] as? [String: Any]
-        self.userAgent = dictionary["userAgent"] as? String
-        self.pitchAlgorithm = dictionary["pitchAlgorithm"] as? String
-
-        updateMetadata(dictionary: dictionary);
-    }
-
-
-    // MARK: - Public Interface
-
-    func toObject() -> [String: Any] {
-        return originalObject
-    }
-
-    func updateMetadata(dictionary: [String: Any]) {
-        self.title = (dictionary["title"] as? String) ?? self.title
-        self.artist = (dictionary["artist"] as? String) ?? self.artist
-        self.date = dictionary["date"] as? String
-        self.album = dictionary["album"] as? String
-        self.genre = dictionary["genre"] as? String
-        self.desc = dictionary["description"] as? String
-        self.duration = dictionary["duration"] as? Double
-        self.artworkURL = MediaURL(object: dictionary["artwork"])
-        self.isLiveStream = dictionary["isLiveStream"] as? Bool
-
-        self.originalObject = self.originalObject.merging(dictionary) { (_, new) in new }
-    }
-
-    // MARK: - AudioItem Protocol
-
-    func getSourceUrl() -> String {
-        return url.isLocal ? url.value.path : url.value.absoluteString
-    }
-
-    func getArtist() -> String? {
-        return artist
-    }
-
-    func getTitle() -> String? {
-        return title
-    }
-
-    func getAlbumTitle() -> String? {
-        return album
-    }
-
-    func getSourceType() -> SourceType {
-        return url.isLocal ? .file : .stream
-    }
-
-    func getArtwork(_ handler: @escaping (UIImage?) -> Void) {
-        if let artworkURL = artworkURL?.value {
-            if(self.artworkURL?.isLocal ?? false){
-                let image = UIImage.init(contentsOfFile: artworkURL.path);
-                handler(image);
-            } else {
-                URLSession.shared.dataTask(with: artworkURL, completionHandler: { (data, _, error) in
-                    if let data = data, let artwork = UIImage(data: data), error == nil {
-                        handler(artwork)
-                    } else {
-                        handler(nil)
-                    }
-                }).resume()
-            }
-        } else {
-            handler(nil)
-        }
-    }
-
-    // MARK: - TimePitching Protocol
-
-    func getPitchAlgorithmType() -> AVAudioTimePitchAlgorithm {
-        if let pitchAlgorithm = pitchAlgorithm {
-            switch pitchAlgorithm {
-            case PitchAlgorithm.linear.rawValue:
-                return .varispeed
-            case PitchAlgorithm.music.rawValue:
-                return .spectral
-            default: // voice
-                return .timeDomain
-            }
-        }
-
-        return .timeDomain
-    }
-
-    // MARK: - Authorizing Protocol
-
-    func getAssetOptions() -> [String: Any] {
-        var options: [String: Any] = [:]
-        if let headers = headers {
-            options["AVURLAssetHTTPHeaderFieldsKey"] = headers
-        }
-        if #available(iOS 16, *) {
-            if let userAgent = userAgent {
-                // there is now an official, working way to set the user-agent for every request
-                // https://developer.apple.com/documentation/avfoundation/avurlassethttpuseragentkey
-                options[AVURLAssetHTTPUserAgentKey] = userAgent
-            }
-        }
-        return options
-    }
-
-}
diff --git a/node_modules/track-player-android/ios/RNTrackPlayer/RNTrackPlayer.swift b/node_modules/track-player-android/ios/RNTrackPlayer/RNTrackPlayer.swift
deleted file mode 100644
index 3be1342..0000000
--- a/node_modules/track-player-android/ios/RNTrackPlayer/RNTrackPlayer.swift
+++ /dev/null
@@ -1,924 +0,0 @@
-//
-//  RNTrackPlayer.swift
-//  RNTrackPlayer
-//
-//  Created by David Chavez on 13.08.17.
-//  Copyright © 2017 David Chavez. All rights reserved.
-//
-
-import Foundation
-import MediaPlayer
-import SwiftAudioEx
-
-@objc(RNTrackPlayer)
-public class RNTrackPlayer: RCTEventEmitter, AudioSessionControllerDelegate {
-
-    // MARK: - Attributes
-
-    private var hasInitialized = false
-    private let player = QueuedAudioPlayer()
-    private let audioSessionController = AudioSessionController.shared
-    private var shouldEmitProgressEvent: Bool = false
-    private var shouldResumePlaybackAfterInterruptionEnds: Bool = false
-    private var forwardJumpInterval: NSNumber? = nil;
-    private var backwardJumpInterval: NSNumber? = nil;
-    private var sessionCategory: AVAudioSession.Category = .playback
-    private var sessionCategoryMode: AVAudioSession.Mode = .default
-    private var sessionCategoryPolicy: AVAudioSession.RouteSharingPolicy = .default
-    private var sessionCategoryOptions: AVAudioSession.CategoryOptions = []
-
-    // MARK: - Lifecycle Methods
-
-    public override init() {
-        super.init()
-        EventEmitter.shared.register(eventEmitter: self)
-        audioSessionController.delegate = self
-        player.playWhenReady = false;
-        player.event.receiveChapterMetadata.addListener(self, handleAudioPlayerChapterMetadataReceived)
-        player.event.receiveTimedMetadata.addListener(self, handleAudioPlayerTimedMetadataReceived)
-        player.event.receiveCommonMetadata.addListener(self, handleAudioPlayerCommonMetadataReceived)
-        player.event.stateChange.addListener(self, handleAudioPlayerStateChange)
-        player.event.fail.addListener(self, handleAudioPlayerFailed)
-        player.event.currentItem.addListener(self, handleAudioPlayerCurrentItemChange)
-        player.event.secondElapse.addListener(self, handleAudioPlayerSecondElapse)
-        player.event.playWhenReadyChange.addListener(self, handlePlayWhenReadyChange)
-    }
-
-    deinit {
-        reset(resolve: { _ in }, reject: { _, _, _  in })
-    }
-
-    // MARK: - RCTEventEmitter
-
-    override public static func requiresMainQueueSetup() -> Bool {
-        return true;
-    }
-
-    @objc(constantsToExport)
-    override public func constantsToExport() -> [AnyHashable: Any] {
-        return [
-            "STATE_NONE": State.none.rawValue,
-            "STATE_READY": State.ready.rawValue,
-            "STATE_PLAYING": State.playing.rawValue,
-            "STATE_PAUSED": State.paused.rawValue,
-            "STATE_STOPPED": State.stopped.rawValue,
-            "STATE_BUFFERING": State.buffering.rawValue,
-            "STATE_LOADING": State.loading.rawValue,
-            "STATE_ERROR": State.error.rawValue,
-
-            "TRACK_PLAYBACK_ENDED_REASON_END": PlaybackEndedReason.playedUntilEnd.rawValue,
-            "TRACK_PLAYBACK_ENDED_REASON_JUMPED": PlaybackEndedReason.jumpedToIndex.rawValue,
-            "TRACK_PLAYBACK_ENDED_REASON_NEXT": PlaybackEndedReason.skippedToNext.rawValue,
-            "TRACK_PLAYBACK_ENDED_REASON_PREVIOUS": PlaybackEndedReason.skippedToPrevious.rawValue,
-            "TRACK_PLAYBACK_ENDED_REASON_STOPPED": PlaybackEndedReason.playerStopped.rawValue,
-
-            "PITCH_ALGORITHM_LINEAR": PitchAlgorithm.linear.rawValue,
-            "PITCH_ALGORITHM_MUSIC": PitchAlgorithm.music.rawValue,
-            "PITCH_ALGORITHM_VOICE": PitchAlgorithm.voice.rawValue,
-
-            "CAPABILITY_PLAY": Capability.play.rawValue,
-            "CAPABILITY_PLAY_FROM_ID": "NOOP",
-            "CAPABILITY_PLAY_FROM_SEARCH": "NOOP",
-            "CAPABILITY_PAUSE": Capability.pause.rawValue,
-            "CAPABILITY_STOP": Capability.stop.rawValue,
-            "CAPABILITY_SEEK_TO": Capability.seek.rawValue,
-            "CAPABILITY_SKIP": "NOOP",
-            "CAPABILITY_SKIP_TO_NEXT": Capability.next.rawValue,
-            "CAPABILITY_SKIP_TO_PREVIOUS": Capability.previous.rawValue,
-            "CAPABILITY_SET_RATING": "NOOP",
-            "CAPABILITY_JUMP_FORWARD": Capability.jumpForward.rawValue,
-            "CAPABILITY_JUMP_BACKWARD": Capability.jumpBackward.rawValue,
-            "CAPABILITY_LIKE": Capability.like.rawValue,
-            "CAPABILITY_DISLIKE": Capability.dislike.rawValue,
-            "CAPABILITY_BOOKMARK": Capability.bookmark.rawValue,
-
-            "REPEAT_OFF": RepeatMode.off.rawValue,
-            "REPEAT_TRACK": RepeatMode.track.rawValue,
-            "REPEAT_QUEUE": RepeatMode.queue.rawValue,
-        ]
-    }
-
-    @objc(supportedEvents)
-    override public func supportedEvents() -> [String] {
-        return EventType.allRawValues()
-    }
-
-    private func emit(event: EventType, body: Any? = nil) {
-        EventEmitter.shared.emit(event: event, body: body)
-    }
-
-    // MARK: - AudioSessionControllerDelegate
-
-    public func handleInterruption(type: InterruptionType) {
-        switch type {
-        case .began:
-            // Interruption began, take appropriate actions (save state, update user interface)
-            emit(event: EventType.RemoteDuck, body: [
-                "paused": true
-            ])
-        case let .ended(shouldResume):
-            if shouldResume {
-                if (shouldResumePlaybackAfterInterruptionEnds) {
-                    player.play()
-                }
-                // Interruption Ended - playback should resume
-                emit(event: EventType.RemoteDuck, body: [
-                    "paused": false
-                ])
-            } else {
-                // Interruption Ended - playback should NOT resume
-                emit(event: EventType.RemoteDuck, body: [
-                    "paused": true,
-                    "permanent": true
-                ])
-            }
-        }
-    }
-
-    // MARK: - Bridged Methods
-
-    private func rejectWhenNotInitialized(reject: RCTPromiseRejectBlock) -> Bool {
-        let rejected = !hasInitialized;
-        if (rejected) {
-            reject("player_not_initialized", "The player is not initialized. Call setupPlayer first.", nil)
-        }
-        return rejected;
-    }
-
-    private func rejectWhenTrackIndexOutOfBounds(
-        index: Int,
-        min: Int? = nil,
-        max : Int? = nil,
-        message : String? = "The track index is out of bounds",
-        reject: RCTPromiseRejectBlock
-    ) -> Bool {
-        let rejected = index < (min ?? 0) || index > (max ?? player.items.count - 1);
-        if (rejected) {
-            reject("index_out_of_bounds", message, nil)
-        }
-        return rejected
-    }
-
-    @objc(setupPlayer:resolver:rejecter:)
-    public func setupPlayer(config: [String: Any], resolve: RCTPromiseResolveBlock, reject: RCTPromiseRejectBlock) {
-        if hasInitialized {
-            reject("player_already_initialized", "The player has already been initialized via setupPlayer.", nil)
-            return
-        }
-
-        // configure buffer size
-        if let bufferDuration = config["minBuffer"] as? TimeInterval {
-            player.bufferDuration = bufferDuration
-        }
-
-        if let autoHandleInterruptions = config["autoHandleInterruptions"] as? Bool {
-            self.shouldResumePlaybackAfterInterruptionEnds = autoHandleInterruptions
-        }
-
-        // configure wether player waits to play (deprecated)
-        if let waitForBuffer = config["waitForBuffer"] as? Bool {
-            player.automaticallyWaitsToMinimizeStalling = waitForBuffer
-        }
-
-        // configure wether control center metdata should auto update
-        player.automaticallyUpdateNowPlayingInfo = config["autoUpdateMetadata"] as? Bool ?? true
-
-        // configure audio session - category, options & mode
-        if
-            let sessionCategoryStr = config["iosCategory"] as? String,
-            let mappedCategory = SessionCategory(rawValue: sessionCategoryStr) {
-            sessionCategory = mappedCategory.mapConfigToAVAudioSessionCategory()
-        }
-
-        if
-            let sessionCategoryModeStr = config["iosCategoryMode"] as? String,
-            let mappedCategoryMode = SessionCategoryMode(rawValue: sessionCategoryModeStr) {
-            sessionCategoryMode = mappedCategoryMode.mapConfigToAVAudioSessionCategoryMode()
-        }
-
-        if
-            let sessionCategoryPolicyStr = config["iosCategoryPolicy"] as? String,
-            let mappedCategoryPolicy = SessionCategoryPolicy(rawValue: sessionCategoryPolicyStr) {
-            sessionCategoryPolicy = mappedCategoryPolicy.mapConfigToAVAudioSessionCategoryPolicy()
-        }
-
-        let sessionCategoryOptsStr = config["iosCategoryOptions"] as? [String]
-        let mappedCategoryOpts = sessionCategoryOptsStr?.compactMap { SessionCategoryOptions(rawValue: $0)?.mapConfigToAVAudioSessionCategoryOptions() } ?? []
-        sessionCategoryOptions = AVAudioSession.CategoryOptions(mappedCategoryOpts)
-
-        configureAudioSession()
-
-        // setup event listeners
-        player.remoteCommandController.handleChangePlaybackPositionCommand = { [weak self] event in
-            if let event = event as? MPChangePlaybackPositionCommandEvent {
-                self?.emit(event: EventType.RemoteSeek, body: ["position": event.positionTime])
-                return MPRemoteCommandHandlerStatus.success
-            }
-
-            return MPRemoteCommandHandlerStatus.commandFailed
-        }
-
-        player.remoteCommandController.handleNextTrackCommand = { [weak self] _ in
-            self?.emit(event: EventType.RemoteNext)
-            return MPRemoteCommandHandlerStatus.success
-        }
-
-        player.remoteCommandController.handlePauseCommand = { [weak self] _ in
-            self?.emit(event: EventType.RemotePause)
-            return MPRemoteCommandHandlerStatus.success
-        }
-
-        player.remoteCommandController.handlePlayCommand = { [weak self] _ in
-            self?.emit(event: EventType.RemotePlay)
-            return MPRemoteCommandHandlerStatus.success
-        }
-
-        player.remoteCommandController.handlePreviousTrackCommand = { [weak self] _ in
-            self?.emit(event: EventType.RemotePrevious)
-            return MPRemoteCommandHandlerStatus.success
-        }
-
-        player.remoteCommandController.handleSkipBackwardCommand = { [weak self] event in
-            if let command = event.command as? MPSkipIntervalCommand,
-               let interval = command.preferredIntervals.first {
-                self?.emit(event: EventType.RemoteJumpBackward, body: ["interval": interval])
-                return MPRemoteCommandHandlerStatus.success
-            }
-
-            return MPRemoteCommandHandlerStatus.commandFailed
-        }
-
-        player.remoteCommandController.handleSkipForwardCommand = { [weak self] event in
-            if let command = event.command as? MPSkipIntervalCommand,
-               let interval = command.preferredIntervals.first {
-                self?.emit(event: EventType.RemoteJumpForward, body: ["interval": interval])
-                return MPRemoteCommandHandlerStatus.success
-            }
-
-            return MPRemoteCommandHandlerStatus.commandFailed
-        }
-
-        player.remoteCommandController.handleStopCommand = { [weak self] _ in
-            self?.emit(event: EventType.RemoteStop)
-            return MPRemoteCommandHandlerStatus.success
-        }
-
-        player.remoteCommandController.handleTogglePlayPauseCommand = { [weak self] _ in
-            self?.emit(event: self?.player.playerState == .paused
-                ? EventType.RemotePlay
-                : EventType.RemotePause
-            )
-
-            return MPRemoteCommandHandlerStatus.success
-        }
-
-        player.remoteCommandController.handleLikeCommand = { [weak self] _ in
-            self?.emit(event: EventType.RemoteLike)
-            return MPRemoteCommandHandlerStatus.success
-        }
-
-        player.remoteCommandController.handleDislikeCommand = { [weak self] _ in
-            self?.emit(event: EventType.RemoteDislike)
-            return MPRemoteCommandHandlerStatus.success
-        }
-
-        player.remoteCommandController.handleBookmarkCommand = { [weak self] _ in
-            self?.emit(event: EventType.RemoteBookmark)
-            return MPRemoteCommandHandlerStatus.success
-        }
-
-        hasInitialized = true
-        resolve(NSNull())
-    }
-
-
-    private func configureAudioSession() {
-
-        // deactivate the session when there is no current item to be played
-        if (player.currentItem == nil) {
-            try? audioSessionController.deactivateSession()
-            return
-        }
-        
-        // activate the audio session when there is an item to be played
-        // and the player has been configured to start when it is ready loading:
-        if (player.playWhenReady) {
-            try? audioSessionController.activateSession()
-            if #available(iOS 11.0, *) {
-                try? AVAudioSession.sharedInstance().setCategory(sessionCategory, mode: sessionCategoryMode, policy: sessionCategoryPolicy, options: sessionCategoryOptions)
-            } else {
-                try? AVAudioSession.sharedInstance().setCategory(sessionCategory, mode: sessionCategoryMode, options: sessionCategoryOptions)
-            }
-        }
-    }
-
-    @objc(isServiceRunning:rejecter:)
-    public func isServiceRunning(resolve: RCTPromiseResolveBlock, reject: RCTPromiseRejectBlock) {
-        // TODO That is probably always true
-        resolve(player != nil)
-    }
-
-    @objc(updateOptions:resolver:rejecter:)
-    public func update(options: [String: Any], resolve: RCTPromiseResolveBlock, reject: RCTPromiseRejectBlock) {
-        if (rejectWhenNotInitialized(reject: reject)) { return }
-
-        var capabilitiesStr = options["capabilities"] as? [String] ?? []
-        if (capabilitiesStr.contains("play") && capabilitiesStr.contains("pause")) {
-            capabilitiesStr.append("togglePlayPause");
-        }
-
-        forwardJumpInterval = options["forwardJumpInterval"] as? NSNumber ?? forwardJumpInterval
-        backwardJumpInterval = options["backwardJumpInterval"] as? NSNumber ?? backwardJumpInterval
-
-        player.remoteCommands = capabilitiesStr
-            .compactMap { Capability(rawValue: $0) }
-            .map { capability in
-                capability.mapToPlayerCommand(
-                    forwardJumpInterval: forwardJumpInterval,
-                    backwardJumpInterval: backwardJumpInterval,
-                    likeOptions: options["likeOptions"] as? [String: Any],
-                    dislikeOptions: options["dislikeOptions"] as? [String: Any],
-                    bookmarkOptions: options["bookmarkOptions"] as? [String: Any]
-                )
-            }
-
-        configureProgressUpdateEvent(
-            interval: ((options["progressUpdateEventInterval"] as? NSNumber) ?? 0).doubleValue
-        )
-
-        resolve(NSNull())
-    }
-
-    private func configureProgressUpdateEvent(interval: Double) {
-        shouldEmitProgressEvent = interval > 0
-        self.player.timeEventFrequency = shouldEmitProgressEvent
-            ? .custom(time: CMTime(seconds: interval, preferredTimescale: 1000))
-            : .everySecond
-    }
-
-    @objc(add:before:resolver:rejecter:)
-    public func add(
-        trackDicts: [[String: Any]],
-        before trackIndex: NSNumber,
-        resolve: RCTPromiseResolveBlock,
-        reject: RCTPromiseRejectBlock
-    ) {
-        // -1 means no index was passed and therefore should be inserted at the end.
-        let index = trackIndex.intValue == -1 ? player.items.count : trackIndex.intValue;
-        if (rejectWhenNotInitialized(reject: reject)) { return }
-        if (rejectWhenTrackIndexOutOfBounds(
-            index: index,
-            max: player.items.count,
-            reject: reject
-        )) { return }
-
-        var tracks = [Track]()
-        for trackDict in trackDicts {
-            guard let track = Track(dictionary: trackDict) else {
-                reject("invalid_track_object", "Track is missing a required key", nil)
-                return
-            }
-
-            tracks.append(track)
-        }
-
-        try? player.add(
-            items: tracks,
-            at: index
-        )
-        resolve(index)
-    }
-
-    @objc(load:resolver:rejecter:)
-    public func load(
-        trackDict: [String: Any],
-        resolve: RCTPromiseResolveBlock,
-        reject: RCTPromiseRejectBlock
-    ) {
-        if (rejectWhenNotInitialized(reject: reject)) { return }
-
-        guard let track = Track(dictionary: trackDict) else {
-            reject("invalid_track_object", "Track is missing a required key", nil)
-            return
-        }
-
-        player.load(item: track)
-        resolve(player.currentIndex)
-    }
-
-    @objc(remove:resolver:rejecter:)
-    public func remove(tracks indexes: [Int], resolve: RCTPromiseResolveBlock, reject: RCTPromiseRejectBlock) {
-        if (rejectWhenNotInitialized(reject: reject)) { return }
-        for index in indexes {
-            if (rejectWhenTrackIndexOutOfBounds(index: index, message: "One or more of the indexes were out of bounds.", reject: reject)) {
-                return
-            }
-        }
-
-        // Sort the indexes in descending order so we can safely remove them one by one
-        // without having the next index possibly newly pointing to another item than intended:
-        for index in indexes.sorted().reversed() {
-            try? player.removeItem(at: index)
-        }
-
-        resolve(NSNull())
-    }
-
-    @objc(move:toIndex:resolver:rejecter:)
-    public func move(
-        fromIndex: NSNumber,
-        toIndex: NSNumber,
-        resolve: RCTPromiseResolveBlock,
-        reject: RCTPromiseRejectBlock
-    ) {
-        if (rejectWhenNotInitialized(reject: reject)) { return }
-        if (rejectWhenTrackIndexOutOfBounds(
-            index: fromIndex.intValue,
-            message: "The fromIndex is out of bounds",
-            reject: reject)
-        ) { return }
-        if (rejectWhenTrackIndexOutOfBounds(
-            index: toIndex.intValue,
-            max: Int.max,
-            message: "The toIndex is out of bounds",
-            reject: reject)
-        ) { return }
-        try? player.moveItem(fromIndex: fromIndex.intValue, toIndex: toIndex.intValue)
-        resolve(NSNull())
-    }
-
-
-    @objc(removeUpcomingTracks:rejecter:)
-    public func removeUpcomingTracks(resolve: RCTPromiseResolveBlock, reject: RCTPromiseRejectBlock) {
-        if (rejectWhenNotInitialized(reject: reject)) { return }
-
-        player.removeUpcomingItems()
-        resolve(NSNull())
-    }
-
-    @objc(skip:initialTime:resolver:rejecter:)
-    public func skip(
-        to trackIndex: NSNumber,
-        initialTime: Double,
-        resolve: RCTPromiseResolveBlock,
-        reject: RCTPromiseRejectBlock
-    ) {
-        let index = trackIndex.intValue;
-        if (rejectWhenTrackIndexOutOfBounds(index: index, reject: reject)) { return }
-
-        if (rejectWhenNotInitialized(reject: reject)) { return }
-
-        print("Skipping to track:", index)
-        try? player.jumpToItem(atIndex: index, playWhenReady: player.playerState == .playing)
-
-        // if an initialTime is passed the seek to it
-        if (initialTime >= 0) {
-            self.seekTo(time: initialTime, resolve: resolve, reject: reject)
-        } else {
-            resolve(NSNull())
-        }
-    }
-
-    @objc(skipToNext:resolver:rejecter:)
-    public func skipToNext(
-        initialTime: Double,
-        resolve: RCTPromiseResolveBlock,
-        reject: RCTPromiseRejectBlock
-    ) {
-        if (rejectWhenNotInitialized(reject: reject)) { return }
-
-        player.next()
-
-        // if an initialTime is passed the seek to it
-        if (initialTime >= 0) {
-            self.seekTo(time: initialTime, resolve: resolve, reject: reject)
-        } else {
-            resolve(NSNull())
-        }
-    }
-
-    @objc(skipToPrevious:resolver:rejecter:)
-    public func skipToPrevious(
-        initialTime: Double,
-        resolve: RCTPromiseResolveBlock,
-        reject: RCTPromiseRejectBlock
-    ) {
-        if (rejectWhenNotInitialized(reject: reject)) { return }
-
-        player.previous()
-
-        // if an initialTime is passed the seek to it
-        if (initialTime >= 0) {
-            self.seekTo(time: initialTime, resolve: resolve, reject: reject)
-        } else {
-            resolve(NSNull())
-        }
-    }
-
-    @objc(reset:rejecter:)
-    public func reset(resolve: RCTPromiseResolveBlock, reject: RCTPromiseRejectBlock) {
-        if (rejectWhenNotInitialized(reject: reject)) { return }
-
-        player.stop()
-        player.clear()
-        resolve(NSNull())
-    }
-
-    @objc(play:rejecter:)
-    public func play(resolve: RCTPromiseResolveBlock, reject: RCTPromiseRejectBlock) {
-        if (rejectWhenNotInitialized(reject: reject)) { return }
-        player.play()
-        resolve(NSNull())
-    }
-
-    @objc(pause:rejecter:)
-    public func pause(resolve: RCTPromiseResolveBlock, reject: RCTPromiseRejectBlock) {
-        if (rejectWhenNotInitialized(reject: reject)) { return }
-
-        player.pause()
-        resolve(NSNull())
-    }
-
-    @objc(setPlayWhenReady:resolver:rejecter:)
-    public func setPlayWhenReady(playWhenReady: Bool, resolve: RCTPromiseResolveBlock, reject: RCTPromiseRejectBlock) {
-        if (rejectWhenNotInitialized(reject: reject)) { return }
-        player.playWhenReady = playWhenReady
-        resolve(NSNull())
-    }
-
-    @objc(getPlayWhenReady:rejecter:)
-    public func getPlayWhenReady(resolve: RCTPromiseResolveBlock, reject: RCTPromiseRejectBlock) {
-        if (rejectWhenNotInitialized(reject: reject)) { return }
-        resolve(player.playWhenReady)
-    }
-
-    @objc(stop:rejecter:)
-    public func stop(resolve: RCTPromiseResolveBlock, reject: RCTPromiseRejectBlock) {
-        if (rejectWhenNotInitialized(reject: reject)) { return }
-
-        player.stop()
-        resolve(NSNull())
-    }
-
-    @objc(seekTo:resolver:rejecter:)
-    public func seekTo(time: Double, resolve: RCTPromiseResolveBlock, reject: RCTPromiseRejectBlock) {
-        if (rejectWhenNotInitialized(reject: reject)) { return }
-
-        player.seek(to: time)
-        resolve(NSNull())
-    }
-
-    @objc(seekBy:resolver:rejecter:)
-    public func seekBy(offset: Double, resolve: RCTPromiseResolveBlock, reject: RCTPromiseRejectBlock) {
-        if (rejectWhenNotInitialized(reject: reject)) { return }
-
-        player.seek(by: offset)
-        resolve(NSNull())
-    }
-
-    @objc(retry:rejecter:)
-    public func retry(resolve: RCTPromiseResolveBlock, reject: RCTPromiseRejectBlock) {
-        if (rejectWhenNotInitialized(reject: reject)) { return }
-        player.reload(startFromCurrentTime: true)
-        resolve(NSNull())
-    }
-
-    @objc(setRepeatMode:resolver:rejecter:)
-    public func setRepeatMode(repeatMode: NSNumber, resolve: RCTPromiseResolveBlock, reject: RCTPromiseRejectBlock) {
-        if (rejectWhenNotInitialized(reject: reject)) { return }
-
-        player.repeatMode = SwiftAudioEx.RepeatMode(rawValue: repeatMode.intValue) ?? .off
-        resolve(NSNull())
-    }
-
-    @objc(getRepeatMode:rejecter:)
-    public func getRepeatMode(resolve: RCTPromiseResolveBlock, reject: RCTPromiseRejectBlock) {
-        if (rejectWhenNotInitialized(reject: reject)) { return }
-
-        resolve(player.repeatMode.rawValue)
-    }
-
-    @objc(setVolume:resolver:rejecter:)
-    public func setVolume(level: Float, resolve: RCTPromiseResolveBlock, reject: RCTPromiseRejectBlock) {
-        if (rejectWhenNotInitialized(reject: reject)) { return }
-
-        player.volume = level
-        resolve(NSNull())
-    }
-
-    @objc(getVolume:rejecter:)
-    public func getVolume(resolve: RCTPromiseResolveBlock, reject: RCTPromiseRejectBlock) {
-        if (rejectWhenNotInitialized(reject: reject)) { return }
-
-        resolve(player.volume)
-    }
-
-    @objc(setRate:resolver:rejecter:)
-    public func setRate(rate: Float, resolve: RCTPromiseResolveBlock, reject: RCTPromiseRejectBlock) {
-        if (rejectWhenNotInitialized(reject: reject)) { return }
-
-        player.rate = rate
-        resolve(NSNull())
-    }
-
-    @objc(getRate:rejecter:)
-    public func getRate(resolve: RCTPromiseResolveBlock, reject: RCTPromiseRejectBlock) {
-        if (rejectWhenNotInitialized(reject: reject)) { return }
-
-        resolve(player.rate)
-    }
-
-    @objc(getTrack:resolver:rejecter:)
-    public func getTrack(index: NSNumber, resolve: RCTPromiseResolveBlock, reject: RCTPromiseRejectBlock) {
-        if (rejectWhenNotInitialized(reject: reject)) { return }
-
-        if (index.intValue >= 0 && index.intValue < player.items.count) {
-            let track = player.items[index.intValue]
-            resolve((track as? Track)?.toObject())
-        } else {
-            resolve(NSNull())
-        }
-    }
-
-    @objc(getQueue:rejecter:)
-    public func getQueue(resolve: RCTPromiseResolveBlock, reject: RCTPromiseRejectBlock) {
-        if (rejectWhenNotInitialized(reject: reject)) { return }
-
-        let serializedQueue = player.items.map { ($0 as! Track).toObject() }
-        resolve(serializedQueue)
-    }
-
-    @objc(setQueue:resolver:rejecter:)
-    public func setQueue(
-        trackDicts: [[String: Any]],
-        resolve: RCTPromiseResolveBlock,
-        reject: RCTPromiseRejectBlock
-    ) {
-        if (rejectWhenNotInitialized(reject: reject)) { return }
-
-        var tracks = [Track]()
-        for trackDict in trackDicts {
-            guard let track = Track(dictionary: trackDict) else {
-                reject("invalid_track_object", "Track is missing a required key", nil)
-                return
-            }
-
-            tracks.append(track)
-        }
-        player.clear()
-        try? player.add(items: tracks)
-        resolve(index)
-    }
-
-    @objc(getActiveTrack:rejecter:)
-    public func getActiveTrack(resolve: RCTPromiseResolveBlock, reject: RCTPromiseRejectBlock) {
-        if (rejectWhenNotInitialized(reject: reject)) { return }
-
-        let index = player.currentIndex
-        if (index >= 0 && index < player.items.count) {
-            let track = player.items[index]
-            resolve((track as? Track)?.toObject())
-        } else {
-            resolve(NSNull())
-        }
-    }
-
-    @objc(getActiveTrackIndex:rejecter:)
-    public func getActiveTrackIndex(resolve: RCTPromiseResolveBlock, reject: RCTPromiseRejectBlock) {
-        if (rejectWhenNotInitialized(reject: reject)) { return }
-
-        let index = player.currentIndex
-        if index < 0 || index >= player.items.count {
-            resolve(NSNull())
-        } else {
-            resolve(index)
-        }
-    }
-
-    @objc(getDuration:rejecter:)
-    public func getDuration(resolve: RCTPromiseResolveBlock, reject: RCTPromiseRejectBlock) {
-        if (rejectWhenNotInitialized(reject: reject)) { return }
-
-        resolve(player.duration)
-    }
-
-    @objc(getBufferedPosition:rejecter:)
-    public func getBufferedPosition(resolve: RCTPromiseResolveBlock, reject: RCTPromiseRejectBlock) {
-        if (rejectWhenNotInitialized(reject: reject)) { return }
-
-        resolve(player.bufferedPosition)
-    }
-
-    @objc(getPosition:rejecter:)
-    public func getPosition(resolve: RCTPromiseResolveBlock, reject: RCTPromiseRejectBlock) {
-        if (rejectWhenNotInitialized(reject: reject)) { return }
-
-        resolve(player.currentTime)
-    }
-
-    @objc(getProgress:rejecter:)
-    public func getProgress(resolve: RCTPromiseResolveBlock, reject: RCTPromiseRejectBlock) {
-        if (rejectWhenNotInitialized(reject: reject)) { return }
-        resolve([
-            "position": player.currentTime,
-            "duration": player.duration,
-            "buffered": player.bufferedPosition
-        ])
-    }
-
-    @objc(getPlaybackState:rejecter:)
-    public func getPlaybackState(resolve: RCTPromiseResolveBlock, reject: RCTPromiseRejectBlock) {
-        if (rejectWhenNotInitialized(reject: reject)) { return }
-        resolve(getPlaybackStateBodyKeyValues(state: player.playerState))
-    }
-
-    @objc(updateMetadataForTrack:metadata:resolver:rejecter:)
-    public func updateMetadata(for trackIndex: NSNumber, metadata: [String: Any], resolve: RCTPromiseResolveBlock, reject: RCTPromiseRejectBlock) {
-        let index = trackIndex.intValue;
-        if (rejectWhenNotInitialized(reject: reject)) { return }
-        if (rejectWhenTrackIndexOutOfBounds(index: index, reject: reject)) { return }
-
-        let track : Track = player.items[index] as! Track;
-        track.updateMetadata(dictionary: metadata)
-
-        if (player.currentIndex == index) {
-            Metadata.update(for: player, with: metadata)
-        }
-
-        resolve(NSNull())
-    }
-
-    @objc(clearNowPlayingMetadata:rejecter:)
-    public func clearNowPlayingMetadata(resolve: RCTPromiseResolveBlock, reject: RCTPromiseRejectBlock) {
-        if (rejectWhenNotInitialized(reject: reject)) { return }
-
-        player.nowPlayingInfoController.clear()
-        resolve(NSNull())
-    }
-
-    @objc(updateNowPlayingMetadata:resolver:rejecter:)
-    public func updateNowPlayingMetadata(metadata: [String: Any], resolve: RCTPromiseResolveBlock, reject: RCTPromiseRejectBlock) {
-        if (rejectWhenNotInitialized(reject: reject)) { return }
-
-        Metadata.update(for: player, with: metadata)
-        resolve(NSNull())
-    }
-
-    private func getPlaybackStateErrorKeyValues() -> Dictionary<String, Any> {
-        switch player.playbackError {
-            case .failedToLoadKeyValue: return [
-                "message": "Failed to load resource",
-                "code": "ios_failed_to_load_resource"
-            ]
-            case .invalidSourceUrl: return [
-                "message": "The source url was invalid",
-                "code": "ios_invalid_source_url"
-            ]
-            case .notConnectedToInternet: return [
-                "message": "A network resource was requested, but an internet connection has not been established and can’t be established automatically.",
-                "code": "ios_not_connected_to_internet"
-            ]
-            case .playbackFailed: return [
-                "message": "Playback of the track failed",
-                "code": "ios_playback_failed"
-            ]
-            case .itemWasUnplayable: return [
-                "message": "The track could not be played",
-                "code": "ios_track_unplayable"
-            ]
-            default: return [
-                "message": "A playback error occurred",
-                "code": "ios_playback_error"
-            ]
-        }
-    }
-
-    private func getPlaybackStateBodyKeyValues(state: AudioPlayerState) -> Dictionary<String, Any> {
-        var body: Dictionary<String, Any> = ["state": State.fromPlayerState(state: state).rawValue]
-        if (state == AudioPlayerState.failed) {
-            body["error"] = getPlaybackStateErrorKeyValues()
-        }
-        return body
-    }
-
-    // MARK: - QueuedAudioPlayer Event Handlers
-
-    func handleAudioPlayerStateChange(state: AVPlayerWrapperState) {
-        emit(event: EventType.PlaybackState, body: getPlaybackStateBodyKeyValues(state: state))
-        if (state == .ended) {
-            emit(event: EventType.PlaybackQueueEnded, body: [
-                "track": player.currentIndex,
-                "position": player.currentTime,
-            ] as [String : Any])
-        }
-    }
-    
-    func handleAudioPlayerCommonMetadataReceived(metadata: [AVMetadataItem]) {
-        let commonMetadata = MetadataAdapter.convertToCommonMetadata(metadata: metadata, skipRaw: true)
-        emit(event: EventType.MetadataCommonReceived, body: ["metadata": commonMetadata])
-    }
-    
-    func handleAudioPlayerChapterMetadataReceived(metadata: [AVTimedMetadataGroup]) {
-        let metadataItems = MetadataAdapter.convertToGroupedMetadata(metadataGroups: metadata);
-        emit(event: EventType.MetadataChapterReceived, body:  ["metadata": metadataItems])
-    }
-
-    func handleAudioPlayerTimedMetadataReceived(metadata: [AVTimedMetadataGroup]) {
-        let metadataItems = MetadataAdapter.convertToGroupedMetadata(metadataGroups: metadata);
-        emit(event: EventType.MetadataTimedReceived, body: ["metadata": metadataItems])
-        
-        // SwiftAudioEx was updated to return the array of timed metadata
-        // Until we have support for that in RNTP, we take the first item to keep existing behaviour.
-        let metadata = metadata.first?.items ?? []
-        let metadataItem = MetadataAdapter.legacyConversion(metadata: metadata)
-        emit(event: EventType.PlaybackMetadataReceived, body: metadataItem)
-    }
-
-    func handleAudioPlayerFailed(error: Error?) {
-        emit(event: EventType.PlaybackError, body: ["error": error?.localizedDescription])
-    }
-
-    func handleAudioPlayerCurrentItemChange(
-        item: AudioItem?,
-        index: Int?,
-        lastItem: AudioItem?,
-        lastIndex: Int?,
-        lastPosition: Double?
-    ) {
-
-        if let item = item {
-            DispatchQueue.main.async {
-                UIApplication.shared.beginReceivingRemoteControlEvents();
-            }
-            // Update now playing controller with isLiveStream option from track
-            if self.player.automaticallyUpdateNowPlayingInfo {
-                let isTrackLiveStream = (item as? Track)?.isLiveStream ?? false
-                self.player.nowPlayingInfoController.set(keyValue: NowPlayingInfoProperty.isLiveStream(isTrackLiveStream))
-            }
-        } else {
-            DispatchQueue.main.async {
-                UIApplication.shared.endReceivingRemoteControlEvents();
-            }
-        }
-
-        if ((item != nil && lastItem == nil) || item == nil) {
-            configureAudioSession();
-        }
-
-        var a: Dictionary<String, Any> = ["lastPosition": lastPosition ?? 0]
-        if let lastIndex = lastIndex {
-            a["lastIndex"] = lastIndex
-        }
-
-        if let lastTrack = (lastItem as? Track)?.toObject() {
-            a["lastTrack"] = lastTrack
-        }
-
-        if let index = index {
-            a["index"] = index
-        }
-
-        if let track = (item as? Track)?.toObject() {
-            a["track"] = track
-        }
-        emit(event: EventType.PlaybackActiveTrackChanged, body: a)
-
-        // deprecated:
-        var b: Dictionary<String, Any> = ["position": lastPosition ?? 0]
-        if let lastIndex = lastIndex {
-            b["lastIndex"] = lastIndex
-        }
-        if let index = index {
-            b["nextTrack"] = index
-        }
-        emit(event: EventType.PlaybackTrackChanged, body: b)
-    }
-
-    func handleAudioPlayerSecondElapse(seconds: Double) {
-        // because you cannot prevent the `event.secondElapse` from firing
-        // do not emit an event if `progressUpdateEventInterval` is nil
-        // additionally, there are certain instances in which this event is emitted
-        // _after_ a manipulation to the queu causing no currentItem to exist (see reset)
-        // in which case we shouldn't emit anything or we'll get an exception.
-        if !shouldEmitProgressEvent || player.currentItem == nil { return }
-        emit(
-            event: EventType.PlaybackProgressUpdated,
-            body: [
-                "position": player.currentTime,
-                "duration": player.duration,
-                "buffered": player.bufferedPosition,
-                "track": player.currentIndex,
-            ]
-        )
-    }
-
-    func handlePlayWhenReadyChange(playWhenReady: Bool) {
-        configureAudioSession();
-        emit(
-            event: EventType.PlaybackPlayWhenReadyChanged,
-            body: [
-                "playWhenReady": playWhenReady
-            ]
-        )
-    }
-}
diff --git a/node_modules/track-player-android/ios/RNTrackPlayer/RNTrackPlayerBridge.h b/node_modules/track-player-android/ios/RNTrackPlayer/RNTrackPlayerBridge.h
deleted file mode 100644
index 125f7eb..0000000
--- a/node_modules/track-player-android/ios/RNTrackPlayer/RNTrackPlayerBridge.h
+++ /dev/null
@@ -1,12 +0,0 @@
-//
-//  RNTrackPlayerBridge.h
-//  RNTrackPlayerBridge
-//
-//  Created by David Chavez on 7/1/17.
-//  Copyright © 2017 David Chavez. All rights reserved.
-//
-
-#import <Foundation/Foundation.h>
-
-@interface RNTrackPlayerBridge: NSObject
-@end
diff --git a/node_modules/track-player-android/ios/RNTrackPlayer/RNTrackPlayerBridge.m b/node_modules/track-player-android/ios/RNTrackPlayer/RNTrackPlayerBridge.m
deleted file mode 100644
index 7741994..0000000
--- a/node_modules/track-player-android/ios/RNTrackPlayer/RNTrackPlayerBridge.m
+++ /dev/null
@@ -1,167 +0,0 @@
-//
-//  RNTrackPlayerBridge.m
-//  RNTrackPlayerBridge
-//
-//  Created by David Chavez on 7/1/17.
-//  Copyright © 2017 David Chavez. All rights reserved.
-//
-
-#import "RNTrackPlayerBridge.h"
-#import <React/RCTBridgeModule.h>
-
-@interface RCT_EXTERN_REMAP_MODULE(TrackPlayerModule, RNTrackPlayer, NSObject)
-
-RCT_EXTERN_METHOD(setupPlayer:(NSDictionary *)data
-                  resolver:(RCTPromiseResolveBlock)resolve
-                  rejecter:(RCTPromiseRejectBlock)reject);
-
-RCT_EXTERN_METHOD(isServiceRunning:(RCTPromiseResolveBlock)resolve
-                  rejecter:(RCTPromiseRejectBlock)reject);
-
-RCT_EXTERN_METHOD(updateOptions:(NSDictionary *)options
-                  resolver:(RCTPromiseResolveBlock)resolve
-                  rejecter:(RCTPromiseRejectBlock)reject);
-
-RCT_EXTERN_METHOD(add:(NSArray *)objects
-                  before:(nonnull NSNumber *)trackIndex
-                  resolver:(RCTPromiseResolveBlock)resolve
-                  rejecter:(RCTPromiseRejectBlock)reject);
-
-RCT_EXTERN_METHOD(move:(nonnull NSNumber *)fromIndex
-                  toIndex:(nonnull NSNumber *)toIndex
-                  resolver:(RCTPromiseResolveBlock)resolve
-                  rejecter:(RCTPromiseRejectBlock)reject);
-
-RCT_EXTERN_METHOD(load:(NSDictionary *)trackDict
-                  resolver:(RCTPromiseResolveBlock)resolve
-                  rejecter:(RCTPromiseRejectBlock)reject);
-
-RCT_EXTERN_METHOD(remove:(NSArray *)objects
-                  resolver:(RCTPromiseResolveBlock)resolve
-                  rejecter:(RCTPromiseRejectBlock)reject);
-
-RCT_EXTERN_METHOD(removeUpcomingTracks:(RCTPromiseResolveBlock)resolve
-                  rejecter:(RCTPromiseRejectBlock)reject);
-
-RCT_EXTERN_METHOD(skip:(nonnull NSNumber *)trackIndex
-                  initialTime:(double)initialTime
-                  resolver:(RCTPromiseResolveBlock)resolve
-                  rejecter:(RCTPromiseRejectBlock)reject);
-
-RCT_EXTERN_METHOD(skipToNext:(double)initialTime
-                  resolver:(RCTPromiseResolveBlock)resolve
-                  rejecter:(RCTPromiseRejectBlock)reject);
-
-RCT_EXTERN_METHOD(skipToPrevious:(double)initialTime
-                  resolver:(RCTPromiseResolveBlock)resolve
-                  rejecter:(RCTPromiseRejectBlock)reject);
-
-RCT_EXTERN_METHOD(reset:(RCTPromiseResolveBlock)resolve
-                  rejecter:(RCTPromiseRejectBlock)reject);
-
-RCT_EXTERN_METHOD(play:(RCTPromiseResolveBlock)resolve
-                  rejecter:(RCTPromiseRejectBlock)reject);
-
-RCT_EXTERN_METHOD(pause:(RCTPromiseResolveBlock)resolve
-                  rejecter:(RCTPromiseRejectBlock)reject);
-
-RCT_EXTERN_METHOD(stop:(RCTPromiseResolveBlock)resolve
-                  rejecter:(RCTPromiseRejectBlock)reject);
-
-RCT_EXTERN_METHOD(setPlayWhenReady:(BOOL)playWhenReady
-                  resolver:(RCTPromiseResolveBlock)resolve
-                  rejecter:(RCTPromiseRejectBlock)reject);
-
-RCT_EXTERN_METHOD(getPlayWhenReady:(RCTPromiseResolveBlock)resolve
-                  rejecter:(RCTPromiseRejectBlock)reject);
-
-RCT_EXTERN_METHOD(retry:(RCTPromiseResolveBlock)resolve
-                  rejecter:(RCTPromiseRejectBlock)reject);
-
-RCT_EXTERN_METHOD(seekTo:(double)time
-                  resolver:(RCTPromiseResolveBlock)resolve
-                  rejecter:(RCTPromiseRejectBlock)reject);
-
-RCT_EXTERN_METHOD(seekBy:(double)offset
-                  resolver:(RCTPromiseResolveBlock)resolve
-                  rejecter:(RCTPromiseRejectBlock)reject);
-
-RCT_EXTERN_METHOD(setRepeatMode:(nonnull NSNumber *)repeatMode
-                  resolver:(RCTPromiseResolveBlock)resolve
-                  rejecter:(RCTPromiseRejectBlock)reject);
-
-RCT_EXTERN_METHOD(getRepeatMode:(RCTPromiseResolveBlock)resolve
-                  rejecter:(RCTPromiseRejectBlock)reject);
-
-RCT_EXTERN_METHOD(setVolume:(float)volume
-                  resolver:(RCTPromiseResolveBlock)resolve
-                  rejecter:(RCTPromiseRejectBlock)reject);
-
-RCT_EXTERN_METHOD(getVolume:(RCTPromiseResolveBlock)resolve
-                  rejecter:(RCTPromiseRejectBlock)reject);
-
-RCT_EXTERN_METHOD(setRate:(float)rate
-                  resolver:(RCTPromiseResolveBlock)resolve
-                  rejecter:(RCTPromiseRejectBlock)reject);
-
-RCT_EXTERN_METHOD(getRate:(RCTPromiseResolveBlock)resolve
-                  rejecter:(RCTPromiseRejectBlock)reject);
-
-RCT_EXTERN_METHOD(getTrack:(nonnull NSNumber *)trackIndex
-                  resolver:(RCTPromiseResolveBlock)resolve
-                  rejecter:(RCTPromiseRejectBlock)reject);
-
-RCT_EXTERN_METHOD(getQueue:(RCTPromiseResolveBlock)resolve
-                  rejecter:(RCTPromiseRejectBlock)reject);
-
-RCT_EXTERN_METHOD(setQueue:(NSArray *)objects
-                  resolver:(RCTPromiseResolveBlock)resolve
-                  rejecter:(RCTPromiseRejectBlock)reject);
-
-RCT_EXTERN_METHOD(getActiveTrack:(RCTPromiseResolveBlock)resolve
-                  rejecter:(RCTPromiseRejectBlock)reject);
-
-RCT_EXTERN_METHOD(getActiveTrackIndex:(RCTPromiseResolveBlock)resolve
-                  rejecter:(RCTPromiseRejectBlock)reject);
-
-RCT_EXTERN_METHOD(getDuration:(RCTPromiseResolveBlock)resolve
-                  rejecter:(RCTPromiseRejectBlock)reject);
-
-RCT_EXTERN_METHOD(getBufferedPosition:(RCTPromiseResolveBlock)resolve
-                  rejecter:(RCTPromiseRejectBlock)reject);
-
-RCT_EXTERN_METHOD(getPosition:(RCTPromiseResolveBlock)resolve
-                  rejecter:(RCTPromiseRejectBlock)reject);
-
-RCT_EXTERN_METHOD(getProgress:(RCTPromiseResolveBlock)resolve
-                  rejecter:(RCTPromiseRejectBlock)reject);
-
-RCT_EXTERN_METHOD(getPlaybackState:(RCTPromiseResolveBlock)resolve
-                  rejecter:(RCTPromiseRejectBlock)reject);
-
-RCT_EXTERN_METHOD(updateMetadataForTrack:(nonnull NSNumber *)trackIndex
-                  metadata:(NSDictionary *)metadata
-                  resolver:(RCTPromiseResolveBlock)resolve
-                  rejecter:(RCTPromiseRejectBlock)reject);
-
-RCT_EXTERN_METHOD(clearNowPlayingMetadata:(RCTPromiseResolveBlock)resolve
-                  rejecter:(RCTPromiseRejectBlock)reject);
-
-RCT_EXTERN_METHOD(updateNowPlayingMetadata:(NSDictionary *)metadata
-                  resolver:(RCTPromiseResolveBlock)resolve
-                  rejecter:(RCTPromiseRejectBlock)reject);
-
-RCT_EXTERN_METHOD(getSleepTimerProgress:(RCTPromiseResolveBlock)resolve
-              rejecter:(RCTPromiseRejectBlock)reject);
-
-RCT_EXTERN_METHOD(setSleepTimer:(double)time
-                  resolver:(RCTPromiseResolveBlock)resolve
-                  rejecter:(RCTPromiseRejectBlock)reject);
-
-RCT_EXTERN_METHOD(sleepWhenActiveTrackReachesEnd:(RCTPromiseResolveBlock)resolve
-                  rejecter:(RCTPromiseRejectBlock)reject);
-
-RCT_EXTERN_METHOD(clearSleepTimer:(RCTPromiseResolveBlock)resolve
-              rejecter:(RCTPromiseRejectBlock)reject);
-
-@end
diff --git a/node_modules/track-player-android/ios/RNTrackPlayer/Support/RNTrackPlayer-Bridging-Header.h b/node_modules/track-player-android/ios/RNTrackPlayer/Support/RNTrackPlayer-Bridging-Header.h
deleted file mode 100644
index 5c9bf51..0000000
--- a/node_modules/track-player-android/ios/RNTrackPlayer/Support/RNTrackPlayer-Bridging-Header.h
+++ /dev/null
@@ -1,7 +0,0 @@
-//
-//  Use this file to import your target's public headers that you would like to expose to Swift.
-//
-
-#import <React/RCTBridgeModule.h>
-#import <React/RCTEventEmitter.h>
-#import <React/RCTConvert.h>
diff --git a/node_modules/track-player-android/ios/RNTrackPlayer/Utils/EventEmitter.swift b/node_modules/track-player-android/ios/RNTrackPlayer/Utils/EventEmitter.swift
deleted file mode 100644
index 6f3afda..0000000
--- a/node_modules/track-player-android/ios/RNTrackPlayer/Utils/EventEmitter.swift
+++ /dev/null
@@ -1,16 +0,0 @@
-import Foundation
-
-class EventEmitter {
-
-    public static var shared = EventEmitter()
-
-    private var eventEmitter: RNTrackPlayer!
-
-    func register(eventEmitter: RNTrackPlayer) {
-        self.eventEmitter = eventEmitter
-    }
-
-    func emit(event: EventType, body: Any?) {
-        self.eventEmitter.sendEvent(withName: event.rawValue, body: body)
-    }
-}
diff --git a/node_modules/track-player-android/ios/RNTrackPlayer/Utils/EventType.swift b/node_modules/track-player-android/ios/RNTrackPlayer/Utils/EventType.swift
deleted file mode 100644
index 6226222..0000000
--- a/node_modules/track-player-android/ios/RNTrackPlayer/Utils/EventType.swift
+++ /dev/null
@@ -1,33 +0,0 @@
-import Foundation
-
-enum EventType: String, CaseIterable {
-    case RemoteDuck = "remote-duck"
-    case RemoteSeek = "remote-seek"
-    case RemoteNext = "remote-next"
-    case RemotePrevious = "remote-previous"
-    case RemoteStop = "remote-stop"
-    case RemotePause = "remote-pause"
-    case RemotePlay = "remote-play"
-    case RemoteJumpForward = "remote-jump-forward"
-    case RemoteJumpBackward = "remote-jump-backward"
-    case RemoteLike = "remote-like"
-    case RemoteDislike = "remote-dislike"
-    case RemoteBookmark = "remote-bookmark"
-    case PlaybackMetadataReceived = "playback-metadata-received"
-    case PlaybackError = "playback-error"
-    case PlaybackQueueEnded = "playback-queue-ended"
-    case PlaybackTrackChanged = "playback-track-changed"
-    case PlaybackActiveTrackChanged = "playback-active-track-changed"
-    case PlaybackState = "playback-state"
-    case PlaybackProgressUpdated = "playback-progress-updated"
-    case PlaybackPlayWhenReadyChanged = "playback-play-when-ready-changed"
-    case SleepTimerChanged = "sleep-timer-changed"
-    case SleepTimerComplete = "sleep-timer-complete"
-    case MetadataChapterReceived = "metadata-chapter-received"
-    case MetadataTimedReceived = "metadata-timed-received"
-    case MetadataCommonReceived = "metadata-common-received"
-    
-    static func allRawValues() -> [String] {
-        return allCases.map { $0.rawValue }
-    }
-}
diff --git a/node_modules/track-player-android/ios/RNTrackPlayer/Utils/Metadata.swift b/node_modules/track-player-android/ios/RNTrackPlayer/Utils/Metadata.swift
deleted file mode 100644
index 70c094d..0000000
--- a/node_modules/track-player-android/ios/RNTrackPlayer/Utils/Metadata.swift
+++ /dev/null
@@ -1,61 +0,0 @@
-//
-//  Metadata.swift
-//  RNTrackPlayer
-//
-//  Created by David Chavez on 23.06.19.
-//  Copyright © 2019 David Chavez. All rights reserved.
-//
-
-import Foundation
-import MediaPlayer
-import SwiftAudioEx
-
-struct Metadata {
-    private static var currentImageTask: URLSessionDataTask?
-
-    static func update(for player: AudioPlayer, with metadata: [String: Any]) {
-        currentImageTask?.cancel()
-        var ret: [NowPlayingInfoKeyValue] = []
-        
-        if let title = metadata["title"] as? String {
-            ret.append(MediaItemProperty.title(title))
-        }
-        
-        if let artist = metadata["artist"] as? String {
-            ret.append(MediaItemProperty.artist(artist))
-        }
-        
-        if let album = metadata["album"] as? String {
-            ret.append(MediaItemProperty.albumTitle(album))
-        }
-        
-        if let duration = metadata["duration"] as? Double {
-            ret.append(MediaItemProperty.duration(duration))
-        }
-        
-        if let elapsedTime = metadata["elapsedTime"] as? Double {
-            ret.append(NowPlayingInfoProperty.elapsedPlaybackTime(elapsedTime))
-        }
-
-        if let isLiveStream = metadata["isLiveStream"] as? Bool {
-            ret.append(NowPlayingInfoProperty.isLiveStream(isLiveStream))
-        }
-        
-        player.nowPlayingInfoController.set(keyValues: ret)
-        
-        if let artworkURL = MediaURL(object: metadata["artwork"]) {
-            currentImageTask = URLSession.shared.dataTask(with: artworkURL.value, completionHandler: { [weak player] (data, _, error) in
-                if let data = data, let image = UIImage(data: data), error == nil {
-                    let artwork = MPMediaItemArtwork(boundsSize: image.size, requestHandler: { (size) -> UIImage in
-                        return image
-                    })
-                    player?.nowPlayingInfoController.set(keyValue: MediaItemProperty.artwork(artwork))
-                }
-            })
-            
-            currentImageTask?.resume()
-        } else {
-            player.nowPlayingInfoController.set(keyValue: MediaItemProperty.artwork(nil))
-        }
-    }
-}
diff --git a/node_modules/track-player-android/ios/RNTrackPlayer/Vendor/SwiftAudio/Classes/RepeatMode.swift b/node_modules/track-player-android/ios/RNTrackPlayer/Vendor/SwiftAudio/Classes/RepeatMode.swift
deleted file mode 100644
index 3109875..0000000
--- a/node_modules/track-player-android/ios/RNTrackPlayer/Vendor/SwiftAudio/Classes/RepeatMode.swift
+++ /dev/null
@@ -1,15 +0,0 @@
-//
-//  RepeatMode.swift
-//  SwiftAudio
-//
-//  Created by David Chavez on 29.05.21.
-//  Copyright © 2021 Double Symmmery. All rights reserved.
-//
-
-import Foundation
-
-public enum RepeatMode: Int {
-    case off
-    case track
-    case queue
-}
diff --git a/node_modules/track-player-android/ios/RNTrackPlayer/Vendor/SwiftAudio/Classes/Utils/DispatchQueueType.swift b/node_modules/track-player-android/ios/RNTrackPlayer/Vendor/SwiftAudio/Classes/Utils/DispatchQueueType.swift
deleted file mode 100644
index 7e1dc52..0000000
--- a/node_modules/track-player-android/ios/RNTrackPlayer/Vendor/SwiftAudio/Classes/Utils/DispatchQueueType.swift
+++ /dev/null
@@ -1,18 +0,0 @@
-//
-//  DispatchQueueType.swift
-//  SwiftAudio
-//
-//  Created by David Chavez on 29.05.21.
-//
-
-import Foundation
-
-public protocol DispatchQueueType {
-    func async(flags: DispatchWorkItemFlags, execute work: @escaping @convention(block) () -> Void)
-}
-
-extension DispatchQueue: DispatchQueueType {
-    public func async(flags: DispatchWorkItemFlags, execute work: @escaping @convention(block) () -> Void) {
-        async(group: nil, qos: .unspecified, flags: flags, execute: work)
-    }
-}
